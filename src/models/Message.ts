// src/models/Message.ts
import mongoose, { Schema, Document, Model, Types } from 'mongoose';

// This interface represents a single message document within a specific chat's collection
export interface IChatMessage extends Document {
  _id: Types.ObjectId;       // Auto-generated by MongoDB for each message document
  sender: Types.ObjectId;    // Ref to User model - who sent the message
  senderUsername: string;    // Denormalized for easy display without populating sender
  receiver: Types.ObjectId;  // Ref to User model - intended recipient
  content: string;
  timestamp: Date;
  read?: boolean;             // Optional: for read receipts
  // No 'chatId' field here if each chat (collection) implicitly defines it
}

const ChatMessageSchema: Schema<IChatMessage> = new Schema({
  sender: {
    type: Schema.Types.ObjectId,
    ref: 'User', // Refers to the 'User' model
    required: true,
  },
  senderUsername: {
    type: String,
    required: true,
    trim: true,
  },
  receiver: { // This field is useful for context even if messages are in a pair-specific collection
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  content: {
    type: String,
    required: true,
    trim: true,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
  read: { // Optional field for read receipts
    type: Boolean,
    default: false,
  },
});

// TTL Index for auto-deletion - messages older than 3 days will be removed
// MongoDB's background TTL monitor runs periodically (default every 60s)
ChatMessageSchema.index({ timestamp: 1 }, { expireAfterSeconds: 3 * 24 * 60 * 60 }); // 3 days in seconds

/**
 * Message Model Factory Function.
 * Returns a Mongoose model for a dynamically named collection based on a chat identifier.
 * Collection names will be like 'chat_userid1_userid2_messages'.
 * Ensures collection names are valid and handles Mongoose model caching.
 *
 * @param {string} chatCollectionIdentifier - The unique identifier part of the collection name,
 *                                         typically generated by sorting and joining two user IDs
 *                                         (e.g., "sortedUserId1_sortedUserId2").
 * @returns {Model<IChatMessage>} A Mongoose model for the specified chat collection.
 * @throws Error if chatCollectionIdentifier is invalid.
 */
const getChatMessageModel = (chatCollectionIdentifier: string): Model<IChatMessage> => {
  if (!chatCollectionIdentifier || typeof chatCollectionIdentifier !== 'string' || chatCollectionIdentifier.trim() === '') {
    throw new Error('Invalid chat collection identifier provided for chat messages model.');
  }

  // Sanitize and construct collection name
  // MongoDB collection name restrictions:
  // - Cannot contain '$'
  // - Cannot be an empty string ""
  // - Should not contain null characters
  // - Should not start with "system." prefix (reserved)
  // - Max length is typically 255 bytes including database name and dot separators.
  // Our generateChatIdentifier from utils.ts should handle basic cleaning of user IDs.
  const sanitizedIdentifier = chatCollectionIdentifier.replace(/[^a-zA-Z0-9_]/g, ''); // Allow only alphanum and underscore
  if (sanitizedIdentifier.length === 0) {
      throw new Error('Sanitized collection identifier is empty.');
  }

  const collectionName = `chat_${sanitizedIdentifier}_messages`;

  // Mongoose caches models. If a model with this name already exists, return it.
  // Otherwise, compile a new one and return it.
  if (mongoose.models[collectionName]) {
    return mongoose.models[collectionName] as Model<IChatMessage>;
  }
  return mongoose.model<IChatMessage>(collectionName, ChatMessageSchema);
};

export default getChatMessageModel;